# CH6. 코틀린 타입 시스템
- 널이 될 수 있는 타입과 널을 처리하는 구문의 문법
- 코틀린 원시 타입 소개와 자바 타입과 코틀린 원시 타입의 관계
- 코틀린 컬렉션 소개와 자바 컬렉션과 코틀린 컬렉션의 관계


자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 몇 가지 특성을 새로 제공한다. <br>
그런 특성으로는 **널이 될 수 있는 타입**과 **읽기 전용 컬렉션**이 있다.

## 널 가능성 
널 가능성 NPE 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다. <br>
코틀린을 비롯한 최신 언어에서 `null`에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 **컴파일 시점**으로 옮기는 것이다. 
널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 널이 될 수 있는 타압
일단 널이 될 수 있는 타입의 동작을 배우기 위해 다음 자바 함수를 살펴보자.
```java
int strLen(String s) {
    return s.length();
}
```

이 함수에 `null`을 넘기면 `NPE`가 발생한다. 그렇다면 이 함수에서 s가 `null`인지 꼭 검사해야 할까? 이는 함수를 사용하는 의도에 따라 달라진다. <br>

이 함수를 코틀린으로 다시 작성해보자. 코틀린에서 이런 함수를 작성할 때 가장 먼저 답을 알아야 할 질문은 "이 함수가 널을 인자로 받을 수 있는가?"이다.
널을 인자로 들어올 수 없다면, 코틀린에서는 다음과 같이 함수를 정의할 수 있다.
```kotlin
fun strLen(s: String) = s.length
```
모든 타입은 기본적으로 널이 될 수 없는 타입이다. 뒤에 `?`가 붙어야 널이 될 수 있다. 

### 타입의 의미
코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다. 널이 될 수 있는 타입과 없는 타입을 구분하면 **각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.**
> #### 자바 타입 시스템의 문제 
> 자바에서는 `String` 타입의 변수에는 `String`이나 `null`이라는 두 가지 종류값이 들어갈 수 있다. 하지만  자바 자체의 `instanceof` 연산자도 `null`이 `String`이 아니라고 답하고, 두 종류의 값에 대해 실행할 수 있는 연산도 완전히 다르다.


### `?.` : 안전한 호출 연산자
호출하려는 값이 `null`이 아니라면 `?.`은 일반 메서드 호출처럼 작동하고, `null`이면 이 호출은 무시되고 `null`이 결과 값이 된다. 

### `?:` : 엘비스 연산자
`null` 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자이다. 

### `as?` : 안전한 캐스트
자바의 `instanceof` 검사 대신 코틀린이 제공하는 더 안전한 타입 캐스트 연산자이다. 
`as`는 자바 타입 캐스트와 마찬가지로 대상 값을 `as`로 지정한 타입으로 바꿀 수 없으면 `ClassCastException`이 발생한다. <br>
(물론 `as`를 사용할 때마다 `is`를 통해 미리 변환 가능한 타입인지 검사해볼 수도 있다. 하지만 안전하면서 간결한 언어를 지향하는 코틀린은 더 나은 해법을 제공한다.)
<br> `as`는 값을 대상 타입으로 변환할 수 없으면 `null`을 반환한다. 
<br><br>
안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다. 예를 들어 `equals`를 구현할 때 이런 패턴이 유용하다. 
```kotlin
/**
 * 안전한 캐스트 연산자를 이용한 equals 구현 패턴
 * 보통 안전한 캐스트를 사용할때 뒤에 엘비스 연산자를 사용하는 패턴을 많이 사용한다.
 */
class Person(val firstName: String, val lastName: String) {
    override fun equals(other: Any?): Boolean {
        val otherPerson = other as? Person ?: return false
        return otherPerson.firstName == firstName &&
                other.lastName == lastName
    }
}
```

### `!!` : 널 아님 단언
코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구이다. <br> 
주의할 점이 있다. <br>
`!!`를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.
어떤 값이 널이었는지 확실히 하기 위해 여러 `!!` 단언문을 한 줄에 함께 쓰는 일을 피하라.
```kotlin
person.company!!.address!!.country // 이렇게 작성하지 말자 
```

### `let` 함수
`let` 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다. 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 `let`을 호출하되 
널이 될 수 없는 타입을 인자로 받는 람다를 `let`에 전달한다.

### 나중에 초기화할 프로퍼티
코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화할 수는 없다.
코틀린에서는 일반적으로 모든 프로퍼티를 초기화해야 한다. 
<br> `lateinit` 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.
```kotlin
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private lateinit var myService: MyService // 초기화하지 않고 널이 될 수 없는 프로퍼티를 선언한다.

    @Before
    fun setUp() {
        mySerive = MyService() // 프로퍼티 초기화
    }

    @Test
    fun testAction() {
        Assert.assertEquals(
            "foo",
            myService.performAction() // 널 검사를 수행하지 않고 프로퍼티를 사용한다.
        )
    }
}
```
**나중에 초기화하는 프로퍼티는 항상 `var`여야 한다.** `val` 프로퍼티는 `final` 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다.

### 널이 될 수 있는 타입 확장
널이 될 수 있는 타입에 대한 확장 함수를 정의하면 `null` 값을 다루는 강력한 도구로 활용할 수 있다.
```kotlin
fun verify(input: String?) {
    if (input.isNullOrBlank()) {
        println()
    }
}
```
자바에서는 `String`의 메소드 `isEmpty()` ,`isBlank()` 와 같은 메서드를 호출할 때도 호출하는 객체가 `null`인지 아닌지가 중요했다.
근데 위의 코틀린 코드에서는 `null`이 될 수 있는 타입의 파라미터를 썼음에도 불구하고 
`null` 접근 처리에 대한 코드없이 호출했다. <br><br>
그에 대한 해답은 확장 함수에 있다.

`null`이 될 수 있는 타입의 확장 함수를 정의하고 사용하면 `null`이 될 수 있는 타입을 파라미터로 갖는 메서드 호출도 자연스럽게 할 수 있다.
```kotlin
fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank()
```
`this.isBlank()` 하는 부분은 앞에서 `null`에 대한 검사를 했기 때문에 스마트 캐스트까지 이뤄진다.<br>
위의 작업은 오직 확장함수에서만 가능하다. 일반 함수에서는 호출하는 객체가 `null`일 떄는 검사 자체가 불가능하다.

### 타입 파라미터의 널 가능성
코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
```kotlin
fun <T> printHashCode(t: T) {
    println(t?.hashCode())
}
```
`T`는 기본적으로 `Any?` 로 추론되어 제네릭 타입은 **항상 널이 될 수 있는 타입**이다.

`null`이 될 수 없는 타입으로 제네릭 타입을 사용하려면 아래와 같이 해야한다.
```kotlin
fun <T : Any> printHashCode(t: T) {
    println(t.hashCode())
}
```

### Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.
코틀린에서는 `Nothing`이라는 특별한 반환 타입이 있다. `Nothing` 타입은 아무 값도 포함하지 않는다. 따라서 `Nothing`은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.
<br> `Nothing`을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제 조건을 검사할 수 있다.
```kotlin
val address = company.address ?: fail("No address")
println(address.city)
```
위 예제에서는 컴파일러는 `company.address`가 널인 경우 엘비스 연산자의 우항에서 예외가 발생한다는 사실을 파악하고, `address` 값이 널이 아님을 추론할 수 있다.


## 컬렉션과 배열
- `List<Int?>` : 리스트 자체는 항상 널이 아니지만, 리스트에 들어있는 각 원소는 널이 될 수도 있다.
- `List<Int>?` : 리스트를 가리키는 변수에는 널이 들어갈 수 있지만, 리스트 안에는 널이 아닌 값만 들어간다.

### 읽기 전용과 변경 가능한 컬렉션
자바 컬렉션과는 다르게 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다. <br>
`kotlin.collections.Collection`은 코틀린 컬렉션을 다룰 때 사용하는 가장 기초적인 인터페이스다. 이 `Collection` 인터페이스를 사용하면 컬렉션 안의 원소에 대해 이터레이션하고, 컬렉션의 크기를 얻고, 어떤 값이 컬렉션 안에 들어있는지 검사하고, 컬렉션에서 데이터를 읽는 여러 다른 연산을 수행할 수 있다.
(`size`, `iterator()`, `contains()`) <br>
하지만 `Collection`에는 원소를 추가하거나 제거하는 메서드가 없다. 컬렉션의 데이터를 수정하려면 **`kotlin.collections.MutableCollection`**을 사용하면 된다! 이는 `Collection`을 확장하면서 원소를 추가하거나, 삭제하거나, 컬렉션 안의 원소를 모두 지우는 등의 메서드를 더 제공한다. (`add()`, `remove()`, `clear()`)
<br>
**코드에서 가능하면 항상 읽기 전용 인터페이스를 사용하는 것을 일반적인 규칙으로 삼자!** <br>

컬렉션 인터페이스를 사용할 때 항상 염두에 둬야 할 핵심은 **읽기 전용 컬렉션이라고 해서 꼭 변경 불가능한 컬렉션일 필요가 없다**는 뜻이다.
하나의 `Collection` 자체를 읽기 전용으로 참조하고 있을 수도 있고, `Mutable collection`으로 참조할 수 있기 때문에 병렬처리 시 원소가 발생하는 상황이 발생할 수 있다.
즉, 이 `Collection`들은 `thread safe`하지 않다.
이때 `ConcurrentModificationException`등의 오류가 발생할 수 있다. <br>
다중 스레드 환경에서 데이터를 다루는 경우, 그 데이터를 적절히 동기화하거나 동시 접근을 허용하는 데이터 구조를 활용해야 한다.

### 코틀린 컬렉션과 자바

코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스라는 두 가지 표현을 제공한다.
코틀린의 읽기 전용과 변경 가능 인터페이스의 기본 구조는 `java.util` 패키지에 있는 자바 컬렉션 인터페이스의 구조를 그대로 옮겨 놓았다.
추가로 변경 가능한 각 인터페이스는 자신과 대응하는 읽기 전용 인터페이스를 확장(상속)한다.

컬렉션 생성 함수

|컬렉션 타입|읽기 전용 타입|변경 가능 타입|
|---|---|----|
|List|listOf|mutableListOf, arrayListOf|
|Set|setOf|mutableSetOf, hashSetOf, linkedSetOf, sortedSetOf|
|Map|mapOf|mutableMapOf, hashMapOf, linkedMapOf, sortedMapOf|

### 객체의 배열과 원시 타입의 배열

- 배열 사용하기
```kotlin
fun main(args: Array<String>) {
    for (i in args.indices) {
        println("Argument $i is: ${args[i]}")
    }
}
```

## 요약
- `as?` 연산자를 사용하면 값을 다른 타입으로 변환하는 것과 변환이 불가능한 경우를 처리하는 것을 한꺼번에 편리하게 처리할 수 있다.
- 자바에서 가져온 타입은 코틀린에서 **플랫폼** 타입으로 취급된다. 개발자는 플랫폼 타입을 널이 될 수 있는 타입으로도, 널이 될 수 없는 타입으로도 사용할 수 있다.
- 널이 될 수 있는 원시 타입(Int? 등)은 자바의 박싱한 원시타입에 대응한다.
- 정상적으로 끝나지 않는 함수의 반환 타입을 지정할 때 `Nothing` 타입을 사용한다.
- 코틀린 컬렉션은 표준 자바 컬렉션 클래스를 사용한다. 하지만 코틀린은 자바보다 컬렉션을 더 개선해서 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공한다.
- 코틀린의 `Array` 클래스는 일반 제네릭 클래스처럼 보인다. 하지만 `Array`는 자바 배열로 컴파일된다.
- 원시 타입의 배열은 `IntArray`와 같이 각 타입에 대한 특별한 배열로 표현된다.