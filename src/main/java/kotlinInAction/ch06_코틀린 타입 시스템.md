# CH6. 코틀린 타입 시스템
- 널이 될 수 있는 타입과 널을 처리하는 구문의 문법
- 코틀린 원시 타입 소개와 자바 타입과 코틀린 원시 타입의 관계
- 코틀린 컬렉션 소개와 자바 컬렉션과 코틀린 컬렉션의 관계


자바와 비교하면 코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 몇 가지 특성을 새로 제공한다. <br>
그런 특성으로는 **널이 될 수 있는 타입**과 **읽기 전용 컬렉션**이 있다.

## 널 가능성 
널 가능성 NPE 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다. <br>
코틀린을 비롯한 최신 언어에서 `null`에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 **컴파일 시점**으로 옮기는 것이다. 
널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 널이 될 수 있는 타압
일단 널이 될 수 있는 타입의 동작을 배우기 위해 다음 자바 함수를 살펴보자.
```java
int strLen(String s) {
    return s.length();
}
```

이 함수에 `null`을 넘기면 `NPE`가 발생한다. 그렇다면 이 함수에서 s가 `null`인지 꼭 검사해야 할까? 이는 함수를 사용하는 의도에 따라 달라진다. <br>

이 함수를 코틀린으로 다시 작성해보자. 코틀린에서 이런 함수를 작성할 때 가장 먼저 답을 알아야 할 질문은 "이 함수가 널을 인자로 받을 수 있는가?"이다.
널을 인자로 들어올 수 없다면, 코틀린에서는 다음과 같이 함수를 정의할 수 있다.
```kotlin
fun strLen(s: String) = s.length
```
모든 타입은 기본적으로 널이 될 수 없는 타입이다. 뒤에 `?`가 붙어야 널이 될 수 있다. 

### 타입의 의미
코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다. 널이 될 수 있는 타입과 없는 타입을 구분하면 **각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.**
> #### 자바 타입 시스템의 문제 
> 자바에서는 `String` 타입의 변수에는 `String`이나 `null`이라는 두 가지 종류값이 들어갈 수 있다. 하지만  자바 자체의 `instanceof` 연산자도 `null`이 `String`이 아니라고 답하고, 두 종류의 값에 대해 실행할 수 있는 연산도 완전히 다르다.


### `?.` : 안전한 호출 연산자
호출하려는 값이 `null`이 아니라면 `?.`은 일반 메서드 호출처럼 작동하고, `null`이면 이 호출은 무시되고 `null`이 결과 값이 된다. 

### `?:` : 엘비스 연산자
`null` 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자이다. 

### `as?` : 안전한 캐스트
자바의 `instanceof` 검사 대신 코틀린이 제공하는 더 안전한 타입 캐스트 연산자이다. 
`as`는 자바 타입 캐스트와 마찬가지로 대상 값을 `as`로 지정한 타입으로 바꿀 수 없으면 `ClassCastException`이 발생한다. <br>
(물론 `as`를 사용할 때마다 `is`를 통해 미리 변환 가능한 타입인지 검사해볼 수도 있다. 하지만 안전하면서 간결한 언어를 지향하는 코틀린은 더 나은 해법을 제공한다.)
<br> `as`는 값을 대상 타입으로 변환할 수 없으면 `null`을 반환한다. 
<br><br>
안전한 캐스트를 사용할 때 일반적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다. 예를 들어 `equals`를 구현할 때 이런 패턴이 유용하다. 
```kotlin
/**
 * 안전한 캐스트 연산자를 이용한 equals 구현 패턴
 * 보통 안전한 캐스트를 사용할때 뒤에 엘비스 연산자를 사용하는 패턴을 많이 사용한다.
 */
class Person(val firstName: String, val lastName: String) {
    override fun equals(other: Any?): Boolean {
        val otherPerson = other as? Person ?: return false
        return otherPerson.firstName == firstName &&
                other.lastName == lastName
    }
}
```

### `!!` : 널 아님 단언
코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구이다. <br> 
주의할 점이 있다. <br>
`!!`를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.
어떤 값이 널이었는지 확실히 하기 위해 여러 `!!` 단언문을 한 줄에 함께 쓰는 일을 피하라.
```kotlin
person.company!!.address!!.country // 이렇게 작성하지 말자 
```

### `let` 함수
`let` 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다. 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 `let`을 호출하되 
널이 될 수 없는 타입을 인자로 받는 람다를 `let`에 전달한다.

### 나중에 초기화할 프로퍼티
코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화할 수는 없다.
코틀린에서는 일반적으로 모든 프로퍼티를 초기화해야 한다. 
<br> `lateinit` 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.
```kotlin
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private lateinit var myService: MyService // 초기화하지 않고 널이 될 수 없는 프로퍼티를 선언한다.

    @Before
    fun setUp() {
        mySerive = MyService() // 프로퍼티 초기화
    }

    @Test
    fun testAction() {
        Assert.assertEquals(
            "foo",
            myService.performAction() // 널 검사를 수행하지 않고 프로퍼티를 사용한다.
        )
    }
}
```
**나중에 초기화하는 프로퍼티는 항상 `var`여야 한다.** `val` 프로퍼티는 `final` 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야 한다.

### 널이 될 수 있는 타입 확장
널이 될 수 있는 타입에 대한 확장 함수를 정의하면 `null` 값을 다루는 강력한 도구로 활용할 수 있다.
```kotlin
fun verify(input: String?) {
    if (input.isNullOrBlank()) {
        println()
    }
}
```
자바에서는 `String`의 메소드 `isEmpty()` ,`isBlank()` 와 같은 메서드를 호출할 때도 호출하는 객체가 `null`인지 아닌지가 중요했다.
근데 위의 코틀린 코드에서는 `null`이 될 수 있는 타입의 파라미터를 썼음에도 불구하고 
`null` 접근 처리에 대한 코드없이 호출했다. <br><br>
그에 대한 해답은 확장 함수에 있다.

`null`이 될 수 있는 타입의 확장 함수를 정의하고 사용하면 `null`이 될 수 있는 타입을 파라미터로 갖는 메서드 호출도 자연스럽게 할 수 있다.
```kotlin
fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank()
```
`this.isBlank()` 하는 부분은 앞에서 `null`에 대한 검사를 했기 때문에 스마트 캐스트까지 이뤄진다.<br>
위의 작업은 오직 확장함수에서만 가능하다. 일반 함수에서는 호출하는 객체가 `null`일 떄는 검사 자체가 불가능하다.

### 타입 파라미터의 널 가능성
```kotlin
fun <T> printHashCode(t: T) {
    println(t?.hashCode())
}
```
`T`는 기본적으로 `Any?` 로 추론되어 제네릭 타입은 **항상 널이 될 수 있는 타입**이다.

`null`이 될 수 없는 타입으로 제네릭 타입을 사용하려면 아래와 같이 해야한다.
```kotlin
fun <T : Any> printHashCode(t: T) {
    println(t.hashCode())
}
```