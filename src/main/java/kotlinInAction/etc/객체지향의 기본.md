# 객체 지향 프로그래밍 (OOP: Object-Oriented Programming)
- 프로그램의 구조를 객체 간 상호작용으로 표현하는 프로그래밍 방식이다.
- 절차적 프로그래밍의 한계를 극복하고자 나온 언어의 한 가지 방법론이다.
- 객체와 관계를 표현하고 이를 통해 확장과 재사용이 용이하다. 
- 코틀린과 자바에서 OOP를 지원한다. 

## 객체지향의 용어
- 추상화(abstraction): 특정 클래스를 만들 때 기본 형식을 규정하는 방법
- 인스턴스(instance): 클래스로부터 객체를 생성
- 상속(inheritance): 부모 클래스의 내용을 자식 클래스가 그대로 물려 받는 것
- 다형성(polymorphism): 하나의 이름으로 다양한 처리를 제공하는 것
- 캡슐화(encapsulation): 내용을 숨기고 필요한 부분만 사용
- 메시지 전송(message sending): 객체들 간에 주고 받는 메시지
- 연관(association): 클래스들의 관계

## 클래스와 추상화
- 클래스(Class)
  - 분류, 계층, 등급 등의 우리말 뜻
  - 특정 대상을 분류하고 특징(속성)과 동작 활동(함수) 내용을 기록한다.
- 추상화(Abstraction)
목표로 하는 것에 대한 필요한 만큼 속성과 동작을 정의하는 과정이다.
  

|코틀린에서 사용하는 용어|그 밖에 용어|
|----|---|
|클래스(Class)|분류, 범주|
|프로퍼티(Property)|속성, 변수, 필드, 데이터, 멤버|
|메서드(Method)|함수, 동작, 행동|
|객체(Object)|인스턴스(Instance)|

객체는 인스턴스화된 것이기 때문에, 메모리 상에 존재한다. <br>
자바에서 사용하는 필드는 코틀린에서 프로퍼티로 부른다.


## 생성자 
- 클래스를 통해 객체가 만들어질 때 기본적으로 호출되는 함수
- 객체 생성 시 필요한 값을 인자로 설정할 수 있게 한다.
- 생성자를 위해 특별한 함수인 `constructor()`를 정의
- 생성자는 주 생성자(Primary Constructor)와 부 생성자(Secondary Constructor)로 나뉘며 
필요에 따라 주 생성자 혹은 부 생성자를 사용할 수 있다. 
- 부 생성자는 필요하면 매개변수를 다르게 여러 번 정의할 수 있다. 

```kotlin
class 클래스명 constructor(필요한 매개변수들) { // 주 생성자의 위치
    ...
    constructor(필요한 매개변수들) {         // 부 생성자의 위치 
        // 프로퍼티의 초기화
    }
  
    [constructor(필요한 매개변수들) { ... }]  // 추가 부생성자
}
```

- 주 생성자: 클래스명과 함께 기술되며 보통의 경우 constructor 키워드를 생략할 수 있다.
- 부 생성자: 클래스 본문에 기술되며 하나 이상의 부 생성자를 정의할 수 있다.


## 상속과 다형성 

### open 키워드를 통한 선언
```kotlin
open class 기반 클래스명 { // open으로 파생 가능 (다른 클래스가 상속 가능한 상태가 된다.)
    ...
}
class 파생 클래스명 : 기반 클래스명() { // 기반 클래스로부터 상속, 최종 클래스로 상속 불가하다.
    ...
}
```
- 코틀린의 모든 클래스는 묵시적으로 Any로부터 상속


### 다형성
같은 이름을 사용하지만 구현 내용이 다르거나 매개변수가 달라서 하나의 이름으로 다양한 기능을 수행할 수 있는 개념
- Static Polymorphism
  - 컴파일 타임에 결정되는 다형성
  - 단순하게 보면 메서드 오버로딩(overloading)을 사용할 때 (기능을 다르게 뱌꾸어 재설계)
- Dynamic Polymorphism
  - 런타임 다형성
  - 동적으로 구성되는 오버라이딩(overriding)된 메서드를 사용할 때 (기능은 같지만, 인자를 다르게) 
- 메서드 오버라이딩 예
```kotlin
open class Bird { // 여기의 open은 상속 가능을 나타낸다.
    ...
    fun fly() { ... } // 1. 최종 메서드로 오버라이딩 불가
    open fun sing() { ... } // 2. sing() 메서드는 하위 클래스에서 오버라이딩 가능
}

class Lark() : Bird() { // 3. 하위 클래스
    fun fly() { /* 재정의 */ } // 에러. 상위 메서드에 open 키워드가 없다.
    override fun sing() { /* 구현부를 새롭게 재정의 */ } // 4. 구현부를 새롭게 작성
}
```
- 파생 클래스에서 오버라이딩을 금지할 때 
```kotlin
open class Lark() : Bird() {
    final override fun sing() { ... }
}
```

## super와 this의 참조: 부모나 내것을 이용하려면
### super로 상위 객체 참조하기
메서드를 오버라이딩하려고 할 때 만일 상위 클래스에서 구현한 내용을 그대로 사용하고 거기에 필요한 내용만 추가하고 싶을 수도 있다.<br>
이때 상위 클래스를 가리키는 특별한 키워드인 super를 사용한다. super를 사용하면 상위 클래스의 프로퍼티나 메서드, 생성자를 사용할 수 있다.

### this로 현재 객체 참조하기
- 여러 개의 부 생성자에서 참조하기
super와 마찬가지로 this를 이용해 프로퍼티, 메서드, 생성자 등을 참조할 수 있다.

### 바깥 클래스 호출하기
엣(@) 기호의 이용
- 이너 클래스에서 바깥 클래스의 상위 클래스를 호출하려면 super 키워드와 함께 엣(@) 기호 옆에 바깥 클래스명을 작성해 호출한다. 


## 정보 은닉 캡슐화 
- 캡슐화(encapsulation): 클래스를 작성할 때 외부에서 숨겨야 하는 속성이나 기능
- 가시성 지시자(visibility modifiers)f를 통해 외부 접근 범위를 결정할 수 있다.
  - public: 이 요소는 어디서든 접근이 가능하다. (기본값)
  - private: 이 지시자가 붙은 요소는 외부에서 접근할 수 없다.
  - protected: 외부에서 접근할 수 없으나 하위 상속 요소에서는 가능하다.
  - internal: 같은 정의의 모듈 내부에서는 접근이 가능하다. (프로젝트 범위)<br>
    (자바에서는 package 키워드가 있지만 코틀린은 internal로 대체하였다.)
    
> 주 생성자에 가시성 지시자가 사용되면 constructor 키워드는 생략할 수 없다.

![img](https://cphinf.pstatic.net/mooc/20200704_83/15937951954811qIEm_PNG/mceclip0.png)


## 클래스와 관계: 연관, 의존, 집합, 구성 
- 연관 : 약한 결합
- 의존 : 강한 결합
- 집합 : 

MutableList : 데이터를 가변적으로 구성할 수 있는 컬렉션 