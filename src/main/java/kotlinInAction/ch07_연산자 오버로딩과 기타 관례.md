
# CH7. 연산자 오버로딩과 기타 관례  
- 연산자 오버로딩  
- 관례: 여러 연산을 지원하기 위해 특별한 이름이 붙은 메서드  
- 위임 프로퍼티  
  
  
코틀린에서는 어떤 언어 기능이 정해진 사용자 작성 함수와 연결되는 몇 가지 경우가 있다. 코틀린에서는 이런 언어 기능이 어떤 타입(클래스)과 연관되기보다는 특정 함수 이름과 연관된다. <br>  
예를 들어, 어떤 클래스 안에 `plus`라는 이름의 특별한 메서드를 정의하면 그 클래스의 인스턴스에 대해ㅐ `+` 연산자를 사용할 수 있다.  
  
이런 식으로 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 **관례**라고 부른다.  
```kotlin  
data class Point(val x: Int, val y: Int)  
```  
위의 클래스를 예제로 계속 사용할 예정이다.  
  
## 산술 연산자 오버로딩  
코틀린에서는 컬렉션에 원소를 추가하는 경우에도 `+=` 연산자를 사용할 수 있다.   
### 이항 산술 연산 오버로딩  
`Point` 클래스에서 두 점의 x와 y 좌표를 더하는 코드를 작성해보자.   
다음은 `+` 연산자 구현을 보여준다.  
```kotlin  
data class Point(val x: Int, val y: Int) {  
    operator fun plus(other: Point) { // plus 라는 이름의 연산자 함수를 정의한다.  
        return Point(x + other.x, y + other.y) // 좌표를 성분 별로 더한 새로운 점을 반환한다.  
    }  
}  
```  
  
`plus` 함수 앞에 `operator` 키워드를 붙이면 된다! 이 키워드를 붙여서 어떤 함수가 관례를 따르는 함수임을 명확히 할 수 있다.  
`+` 연산자는 `plus` 함수 호출로 컴파일 된다.  
연산자를 멤버 함수로 만드는 대신 확장 함수로 정의할 수도 있다.  
```kotlin  
operator fun Point.plus(other: Point): Point {  
    return Point(x + other.x, y + other.y)  
}  
```  
외부 함수의 클래스에 대한 연산자를 정의할 때는 관례를 따르는 이름의 확장 함수로 구현하는 게 일반적인 패턴이다.  
  
> 오버로딩 가능한 이항 산술 연산자   
|식|함수 이름|  
|---|---|  
|a * b|times|  
|a / b|div|  
|a % b|mod|  
|a + b|plus|  
|a - b|minus|  
  
### 복합 대입 연산자 오버로딩  
코틀린은 `+` 연산자뿐 아니라 그와 관련 있는 연산자인 `+=`도 자동으로 함께 지원한다. `+=`, `-=` 등의 연산자는 **복합 대입 연산자**라고 불린다.  
```kotlin  
    var point = Point(3, 4)  
    point += Point(2, 3)  
    println(point) // Point(x=5, y=7)  
```  
  
경우에 따라 `+=` 연산이 객체에 대한 참조를 다른 참조로 바꾸기보다 원래 객체의 내부 상태를 변경하게 만들고 싶을 때가 있다. 변경 가능한 컬렉션에 원소를 추가하는 경우가 대표적인 예다.  
  
```kotlin  
val numbers = ArrayList<Int>()  
numbers += 42  
```  
  
### 단항 연산자 오버로딩  
```kotlin  
operator fun Point.unaryMinus(): Point {  
    retrun Point(-x, -y)  
}  
  
val p = Point(10, 20)  
println(-p)  
```  
  
> 오버로딩 가능한 단항 산술 연산자  
  
|식|함수 이름|  
|---|---|  
|+a|unaryPlus|  
|-a|unaryMinus|  
|!a|not|  
|++a, a++|inc|  
|--a, a--|dec|

## 비교 연산자 오버로딩
### 동등성 연산자: equals
코틀린은 `==` 연산자 호출을 `equals` 메서드 호출로 컴파일한다. `!=` 연산자를 사용하는 식도 `equals` 호출로 컴파일된다. 이는 내부에서 인자가 널인지 검사하므로 다른 연산과 달리 널이 될 수 있는 값에도 적용할 수 있다. <br>
식별자 비교 연산자(`===`)는 자신의 두 피연산자가 서로 같은 객체를 가리키는지 비교한다.

### 순서 연산자: compareTo
코틀린은 `Comparable` 인터페이스 안에 있는 `compareTo` 메서드를 호출하는 관례를 제공한다. 따라서 비교 연산자(`<`, `>`, `<=`, `>=`)는 `compareTo`  호출로 컴파일된다. `compareTo`가 반환하는 값은 `Int`다.
```kotlin
a >= b 👉 a.compareTo(b) >= 0
```

```kotlin
class Person(
	val firstName: String, val lastName: String
) : Comparable<Person> {
	override fun compareTo(other: Person): Int {
		return compareValuesBy(this, other, // 인자로 받은 함수를 차례로 호출하면서 값을 비교한다.
			Person::lastName, Person::firstName)
	}
}
```
#### compareValuesBy 
`compareValuesBy`는 두 객체와 여러 비교 함수를 인자로 받는다.  첫 번째 비교 함수에 두 객체를 넘겨서 두 객체가 같지 않다는 결과(0이 아닌 값)가 나오면 그 결과 값을 즉시 반환하고, 두 객체가 같다는 결과(0)가 나오면 두 번째 비교 함수를 통해 두 객체를 비교한다.
