# CH1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

자바 역사 통틀어 가장 큰 변화가 자바 8에서 일어났다.<br>
예를 들어 사과 목록을 무게순으로 **정렬**하는 고전적인 코드를 봐보자.
```java
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight);
    }
});
```
이 코드를 자바 8으로 이용하면 **자연어**에 더 가깝게 간단한 방식으로 코드를 구현할 수 있다.<br>
다음 코드는 사과의 무게를 비교해서 목록에서 정렬한다.
```java
inventory.sort(comparing(Apple::getWeight));
```

## 자바 8에서 제공하는 새로운 기술
- 스트림 API<br>
  **병렬 연산**을 지원하는 스트림 API를 제공한다. 이를 이용하면 비용이 비싸고 에러를 자주 일으키는 `synchronized` 키워드를 이용하지 않아도 된다.<br>
  또한, 밑에 있는 두 가지 기법들은 스트림 API 덕분에 존재한다.
- 메서드에 코드를 전달하는 기법(메서드 참조와 람다)<br>
  기존의 익명 클래스를 이용하는 것보다 간단 명료하게 동작 파라미터화를 구현할 수 있다.
  이 기법은 **함수형 프로그래밍**에서 위력을 발휘한다.
- 인터페이스의 디폴트 메서드<br>


## 자바 8 설계의 밑바탕을 이루는 세가지 프로그래밍 개념
### 스트림 처리
> 스트림<br>
> 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.<br>
> 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

자바 8에는 `java.util.stream` 패키지에 `스트림 API`가 추가 되었다. 스트림 패키지에 정의된 `Stream<T>`는 T 형식으로 구성된 일련의 항목을 의미한다.<br>
`스트림 API`는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다. `스트림 API`의 핵심은 기존에는 한 번에 한 항목을 처리했지만, 이제 자바 8에서는 우리가 하려는 작업을 데이터베이스 질의처럼 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다.<br>
또한 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다.<br>
스레드라는 복잡한 작업을 사용하지 않으면서도 **공짜**로 병렬성을 얻을 수 있다.

### 동작 파라미터화로 메서드에 코드 전달하기
코드 일부를 API로 전달하는 기능이다. 기존에 자바는 메서드를 다른 메서드의 파라미터로 전달할 수 없었다.
정렬 기능을 위해서 익명 함수 형태로 `Comparator`를 구현하는 방법도 있지만 복잡하다. <br>
**자바 8에서는 메서드를 다른 메서드의 파라미터로 전달 할 수 있다.** 이러한 기능을 이론적으로 동작 파라미터화라고 부른다.<br>
동작 파라미터화가 중요한 이유는 `스트림 API`는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다.

### 병렬성과 공유 가변 데이터
이 개념은 "병렬성을 공짜로 얻을 수 있다"라는 말에서 시작된다. <br>
병렬성을 공짜로 얻기 위해서는 다른 한 가지를 포기해야 하는데,  
스트림 메서드로 전달하는 코드의 _동작 방식_을 조금 바꿔야 한다. 처음에는 불편하지만 나중에는 편하게 느껴질 것이다.
스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 **안전하게 실행**될 수 있어야 한다.<br>
보통 다른 코드와 동시에 실행 하더라도 안전하게 실행할 수 있는 코드를 만들려면 가변 데이터(shared mutable data)에 접근하지 않아야 한다. <br>
이러한 함수를 순수(pure) 함수, 부작용 없는 함수(side-effect-free), 상태 없는(stateless) 함수라고 부른다.

## 자바 함수
일급 객체는 아래 3개의 조건을 충족하는 객체를 1급 객체라고 정의할 수 있다.
- 변수와 데이터에 할당할 수 있어야 한다.
- 객체의 인자로 넘길 수 있어야 한다.
- 객체의 리턴값으로 리턴할 수 있어야 한다.

위 조건에 근거해서, 자바의 일급 시민은 객체(일반, 참조 자료형)이다.<br>
하지만 프로그래밍 패러다임이 변하면서 함수형 프로그래밍이 대두되었다.
자바 8에서는 함수와 람다(익명 함수)를 값으로 취급한다. <br>
멀티 코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계할 수 있도록 함수를 만들었기 때문이다.

#### 함수를 값으로 취급함으로써 얻는 장점
기존에는 객체로 메서드를 감싼 다음에 전달해야 했지만 자바 8에서는 메서드 참조 문법인 `::`을 이용해서 직접 메서드를 메서드로 전달할 수 있다.

### 메서드와 람다를 일급 시민으로
#### 1. 메서드 참조
디렉토리에서 모든 숨겨진 파일을 필터링한다고 가정하자. 우선 주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드를 구현해야 한다.
`File` 클래스는 이미 `isHidden` 메서드를 제공한다. (`File` 클래스를 인수로 받아 `boolean`을 반환하는 함수)
```java
  File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
      @Override
      public boolean accept(File file) {
          return file.isHidden(); // <- 숨겨진 파일 필터링
      }
  });
```
`File` 클래스에 이미 `isHidden`이라는 메서드가 있는데 굳이 `FileFilter`로 `isHidden`을 복잡하게 감싼 후 `FileFilter`를 인스턴스화해야 할까?<br>
자바 8 전까지는 달리 방법이 없었지만 자바 8에서는 다음처럼 코드를 구현할 수 있다.
```java
  File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
이미 `isHidden`이라는 함수는 준비되어 있으므로 자바 8의 **메서드 참조 `::`** (이 메서드를 값으로 사용하라)를 이용해서 `listFiles`에 직접 전달할 수 있다.<br>
_여기서 메서드가 아닌 함수라는 용어를 사용했다는 사실을 주목하자._<br>

#### 2. 람다 : 익명 함수
자바 8에서는 메서드를 일급 값으로 취급할 뿐 아니라 **람다**(또는 익명함수 anonymous functions)를 포함하여 함수도 값으로 취급할 수 있다.<br>
예를 들어, `(int x) -> x + 1`, 즉 x라는 인수로 호출하면 x + 1을 반환하는 동작을 수행하도록 코드를 구현할 수 있다.


### 스트림
거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다.<br>
예를 들어, 고가의 트랜잭션(transaction)만 필터링한 다음에 통화로 결과를 그룹화해야 한다고 가정하자. 아래와 같은 많은 기본 코드를 구현해야한다.
```java
Map<Curreny, List<Transaction>> transactionByCurrencies = new HashMap<>(); // 그룹화된 트랜잭션을 더할 Map 생성
for(Transaction transaction : transactions) { // 트랜잭션의 리스트 반복
  if(transaction.getPrice() > 1000) { // 고가의 트랜잭션 필터링
    Curreny curreny = transacation.getCurrency(); // 트랜잭션의 통화를 추출
    List<Transcation> transactionsForCurrency = transactionsByCurrencies.get(currency);
    if(transactionsForCurrency == null) { // 현재 통화의 그룹된 맵에 항목이 없으면 새로 만든다.
      transactionsForCurrency = new ArrayList<>();
      transactionsByCurrencies.put(currenc, transcationsForCurrency);
    }
    transactionsForCurrency.add(transacation); // 현재 탐색된 트랜잭션을 같은 통화의 트랜잭션 리스트에 추가한다.
  }
}
``` 
위 예제 코드는 중첩된 제어 흐름 문장이 많아 코드를 한 번에 이해하기도 어렵다.<br>
`스트림 API`를 이용하면 다음처럼 문제를 해결할 수 있다.
```java
import static java.util.stream.Collectors.groupingBy;
Map<Currency, List<Transaction>> transactionsByCurrencies = 
        transactions.stream()
            .filter((Transcations t) -> t.getPrice() > 1000) // 고가의 트랜잭션 필터링
            .collect(groupingBy(Transcation::getCurrency)); // 통화로 그룹화
```
(CH4 - 7에서 `스트림 API`를 자세히 설명함.)<br>
우선 `스트림 API`를 이용하면 `컬렉션 API`와는 상당히 다른 방식으로 데이터를 처리할 수 있다.<br>
컬렉션에서는 반복 과정을 직접 처리해야 했다. (`for-each` 루프를 이용해 각 요소를 반복하면서 작업을 수행했다.)<br>
이런 방식의 반복을 **외부 반복**이라고 한다. <br>
반면 `스트림 API`를 이용하면 루프를 신경 쓸 필요가 없다. `스트림 API`에서는 라이브러리 내부에서 모든 데이터가 처리된다. <br>
이와 같은 반복을 **내부 반복**이라고 한다. <br>

### 멀티스레딩
이전 자바에서 제공하는 스레드 API로 **멀티스레딩** 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다.<br>
멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있다. 결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있어 순차적인 모델보다 다루기 어렵다. <br>
자바 스트림 API(`java.util.stream`)로 **컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제** 그리고 **멀티코어 활용 어려움**이라는 2가지 문제를 모두 해결했다.<br>
_컬렉션_ 은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면, **스트림**은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다.<br>
스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환겨을 제공한다는 것이 핵심이다.<br>
스트림과 람다 표현식을 이용하면 "병렬성을 공짜로" 얻을 수 있다. <br><br>다음은 리스트에서 무거운 사과를 순차적으로 또는 병렬로 필터링하는 방법이다.<br>
- 순차 처리 방식의 코드
```java
import static java.util.stream.Collectors.toList;

List<Apple> heavyApples = 
	inventory.stream().filter((Apple a) -> a.getWeight() > 150)
    			  .collect(toList());
```
- 병렬 처리 방식의 코드
```java
import static java.util.stream.Collectors.toList;

List<Apple> heavyApples = 
	inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
    			  	  .collect(toList());
```
무조건 병렬 처리가 좋은 것만은 아니다.<br>
아주 큰 파일 또는 데이터를 가공하는 작업을 할 때를 제외하고는 순차 처리 스트림이 나을 것이다. (성능)

### 디폴트 메서드와 자바 모듈
자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.<br>
디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다.<br>
어떻게 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경할 수 있을까라는 딜레마를 디폴트 메서드가 해소 시켜준다. <br>
기존에는 인터페이스에 메서드가 하나 추가되면 인터페이스를 사용하는 모든 곳에서 메서드를 추가해야 하지만,<br>
디폴트 메서드는 구현하지 않아도 되는 메서드이다. 메서드 본문은 클래스 구현이 아니라 인터페이스 일부로 포함된다. (그래서 이를 디폴트 메서드라고 한다.)
> #### 추가 정리
> 익명 클래스 <br>
>  InnerClass(내부 클래스)의 한 종류이다.
> 익명 클래스를 사용하는 가장 큰 목적은 부모 클래스를 상속받는 _서브 클래스를 생성하지 않고도_, 단일 객체를 만들어서 부모 클래스에 정의된 동작에서 행위를 추가할 수 있다는 것이다. <br>
> <br>
> 익명 클래스와 일반 클래스의 차이
> - 일반 클래스는 인터페이스를 제한 없이 상속받을 수 있지만, 익명 클래스는 **단 하나의 인터페이스/클래스만**을 구현할 수 있다.
> - 익명 클래스는 별도의 생성자를 작성할 수 없다. 만들어진 클래스의 생성자와 동일하게 객체를 생성할 뿐이다.
    익명 클래스는 클래스와 인터페이스로부터 만들 수 있다.
#### 참고
- [[Brunch] 함수형 인터페이스와 함께 자바 8에 녹아든 람다](https://brunch.co.kr/@kd4/12)